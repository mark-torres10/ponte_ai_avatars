import { Router, Request, Response } from 'express';
import { logger } from '../utils/logger';

const router = Router();

interface OpenAIPersonaRequest {
  name: string;
  toneCategories: string[];
  personalityTraits: {
    extroversion: number;
    formality: number;
    energy: number;
    professionalism: number;
  };
  customTone?: string;
  interviewAnswers?: Record<string, string>;
}

interface OpenAIPersonaResponse {
  success: boolean;
  persona?: string;
  error?: string;
}

// Generic OpenAI prompt request interface
interface OpenAIRequest {
  prompt: string;
  model?: string;
  maxTokens?: number;
  temperature?: number;
}

interface OpenAIResponse {
  success: boolean;
  content?: string;
  error?: string;
}

// Generate AI persona
router.post('/generate-persona', async (req: Request, res: Response): Promise<void> => {
  try {
    const request: OpenAIPersonaRequest = req.body;

    // Validate request
    if (!request.name || !request.toneCategories || !request.personalityTraits) {
      res.status(400).json({
        success: false,
        error: 'Missing required fields: name, toneCategories, personalityTraits',
      });
      return;
    }

    // For now, return a mock response since we don't have the actual API key
    // In production, this would make a real API call to OpenAI
    const response = await generateMockPersona(request);

    res.json(response);
  } catch (error) {
    logger.error('Error generating persona:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
    });
  }
});

// Generic OpenAI prompt endpoint
router.post('/prompt', async (req: Request, res: Response): Promise<void> => {
  try {
    const request: OpenAIRequest = req.body;

    // Validate request
    if (!request.prompt) {
      res.status(400).json({
        success: false,
        error: 'Missing required field: prompt',
      });
      return;
    }

    // For now, return a mock response
    // In production, this would make a real API call to OpenAI
    const response = await generateMockOpenAIResponse(request);

    res.json(response);
  } catch (error) {
    logger.error('Error processing OpenAI prompt:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
    });
  }
});

// Mock persona generation (replace with real OpenAI API call)
async function generateMockPersona(request: OpenAIPersonaRequest): Promise<OpenAIPersonaResponse> {
  try {
    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 2000));

    const { name, toneCategories, personalityTraits, customTone } = request;
    
    // Generate a realistic persona based on the input data
    const persona = buildPersonaFromData(name, toneCategories, personalityTraits, customTone);
    
    return {
      success: true,
      persona,
    };
  } catch (error) {
    logger.error('Error generating mock persona:', error);
    return {
      success: false,
      error: 'Failed to generate persona',
    };
  }
}

// Mock OpenAI response (replace with real OpenAI API call)
async function generateMockOpenAIResponse(request: OpenAIRequest): Promise<OpenAIResponse> {
  try {
    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 1000));

    // For now, just echo back a modified version of the prompt
    const content = `AI Response to: "${request.prompt}"\n\nThis is a mock response. In production, this would be generated by OpenAI's API.`;

    return {
      success: true,
      content,
    };
  } catch (error) {
    logger.error('Error generating mock OpenAI response:', error);
    return {
      success: false,
      error: 'Failed to generate response',
    };
  }
}

function buildPersonaFromData(
  name: string,
  toneCategories: string[],
  personalityTraits: Record<string, number>,
  customTone?: string
): string {
  const toneDescriptions = {
    professional: 'professional and corporate communication',
    friendly: 'warm and approachable interactions',
    authoritative: 'confident and leadership-focused communication',
    casual: 'relaxed and informal conversations',
    enthusiastic: 'energetic and motivational content',
    calm: 'serene and composed delivery',
    humorous: 'entertaining and light-hearted communication',
    serious: 'focused and detail-oriented presentations',
  };

  const personalityDescriptions = {
    extroversion: (personalityTraits['extroversion'] ?? 50) > 50 ? 'outgoing and engaging' : 'thoughtful and reflective',
    formality: (personalityTraits['formality'] ?? 50) > 50 ? 'polished and professional' : 'approachable and relatable',
    energy: (personalityTraits['energy'] ?? 50) > 50 ? 'dynamic and energetic' : 'measured and composed',
    professionalism: (personalityTraits['professionalism'] ?? 50) > 50 ? 'corporate-ready' : 'authentically human',
  };

  const selectedTones = toneCategories
    .map(tone => toneDescriptions[tone as keyof typeof toneDescriptions])
    .filter(Boolean)
    .join(', ');

  const persona = `Meet ${name}, a dynamic AI avatar that excels in ${selectedTones || 'versatile communication'}.

With a personality that balances ${personalityDescriptions.extroversion} energy with ${personalityDescriptions.formality} communication style, this avatar delivers ${personalityDescriptions.energy} content while maintaining ${personalityDescriptions.professionalism} standards.

${customTone ? `Custom characteristics: ${customTone}` : ''}

Perfect for: ${getUseCases(toneCategories)}`;

  return persona;
}

function getUseCases(toneCategories: string[]): string {
  const useCases = {
    professional: 'corporate training, business presentations, executive communications',
    friendly: 'customer service, community engagement, educational content',
    authoritative: 'leadership training, motivational speaking, industry expertise',
    casual: 'social media content, casual conversations, lifestyle content',
    enthusiastic: 'motivational content, product launches, celebration videos',
    calm: 'meditation guides, relaxation content, soothing presentations',
    humorous: 'entertainment content, comedy, light-hearted marketing',
    serious: 'technical training, academic content, detailed explanations',
  };

  const selectedUseCases = toneCategories
    .map(tone => useCases[tone as keyof typeof useCases])
    .filter(Boolean);

  return selectedUseCases.length > 0 ? selectedUseCases.join(', ') : 'versatile content creation';
}

export default router; 